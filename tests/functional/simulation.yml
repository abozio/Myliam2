globals:
    periodic:
        - MINR: float
        - WEMRA: int
        - MIG_PERCENT: float

#    MIG:
#        type: float
    MIG: {type: float}

    othertable:
        fields:
            - INTFIELD: int
            - FLOATFIELD: float

    othertable_noperiod:
        fields:
            - INTFIELD: int

entities:
#    test:
#        fields:
#            - test_field: int

    household:
        fields:
            - num_persons:  {type: int, initialdata: False}
            - nch:          {type: int, initialdata: False}
            - start_period: {type: int, initialdata: False}
            - clone_id:     {type: int, initialdata: False}
            - weight:       {type: int, initialdata: False}
            # period and id are usually implicit, but we include them here
            # anyway for the sake of testing
            - period: int
            - id: int

        links:
            persons: {type: one2many, target: person, field: hh_id}

        processes:
            setweight: 
                - weight: randint(2, 32)
               
            expand:
                - last_non_clone_id: grpmax(id)
                - toclone: weight > 1
                - clone_id: clone(toclone)
                - is_clone: id > last_non_clone_id
                - weight: if(toclone,
                             trunc((weight + 1) / 2),
                             if(is_clone,
                                trunc(weight / 2),
                                1))
            
            check:
                - show('min/max weight:', grpmin(weight), grpmax(weight))
                - show('total population:', grpsum(countlink(persons)),
                       '/ expanded:', grpsum(weight * countlink(persons)))

            num_persons: countlink(persons)
            nch: countlink(persons, age <= 18)
            maxnch: grpmax(nch)
            dump_csv_h: csv(dump())
            aligned: False

            test_align_link:
                - num_persons: countlink(persons)
                # kill empty households 
                - remove(num_persons == 0)
                
                - total_population: grpsum(num_persons)
                - show("total:", grpcount(), "households /",
                                 total_population, "persons")

                # MIG_PERCENT is a simple float periodic global
                - num_migrants: total_population * MIG_PERCENT
                - qshow(num_migrants)

                # MIG is a 3d table but we want the 2d table for this period
                # currently, we need to manually compute the index
                - base_period: 2000
                - mig_period: MIG[:,:,period - base_period]

                # Distribute total desired migrants, by age and sex
                - need: num_migrants * mig_period
                
                # sanity check
                - assertTrue(abs(need.sum() - num_migrants) < 1e-4)

                # without filter
                - aligned_all: align_abs(countlink(persons), need,
                                         link=persons, secondary_axis=gender)
                - qshow(grpcount(aligned_all),
                        grpsum(num_persons, filter=aligned_all))

                # with a filter
                - is_candidate: uniform() < 0.5
                - qshow(grpcount(is_candidate),
                        grpsum(num_persons, filter=is_candidate))

                - aligned: align_abs(countlink(persons), need,
                                     link=persons, secondary_axis=gender,
                                     errors='carry',
                                     filter=is_candidate)
                - qshow(grpcount(aligned),
                        grpsum(num_persons, filter=aligned))

#                - clone_id: clone(aligned)

                # with pvalues != range(0, X)
                - bchoice: choice([False, True])
                - weird_num: choice([5, 25, 45, 65, 85, 105])
                - weird_need: groupby(bchoice, weird_num, expr=10)
                - show(weird_need)
                - show('by sex', weird_need.sum(axis=1))
                - aligned: align_abs(countlink(persons), weird_need,
                                     link=persons, secondary_axis=0,
                                     filter=is_candidate,
                                     expressions=[gender, 5 + trunc(age / 20) * 20])
                - qshow(grpcount(aligned),
                        grpsum(num_persons, filter=aligned))


    person:
        fields:
            # period and id are implicit
            - age:          int
            - dead:         bool
            - gender:       bool
            - work:         bool

            - partner_id:   int
            - hh_id:        int
            - f_id:         int
            - m_id:         int

            - weight:       {type: int, initialdata: False}
            - v1:           {type: float, initialdata: False}
            - nch:          {type: int, initialdata: False}
            - eduach:       {type: int, initialdata: False}
            - agegroup:     {type: int, initialdata: False}
            - ch_minage:    {type: int, initialdata: False}
            - ch_maxage:    {type: int, initialdata: False}
            - young_mother: {type: bool, initialdata: False}

        links:
            partner: {type: many2one, target: person, field: partner_id}
            household: {type: many2one, target: household, field: hh_id}
            father: {type: many2one, target: person, field: f_id}
            mother: {type: many2one, target: person, field: m_id}
            children: {type: one2many, target: person, field: m_id}

        macros:
            ISCHILD: age < 18

#            BOY: ISCHILD and MALE
#            GIRL: ISCHILD and FEMALE

            MALE: gender
            FEMALE: not gender

            CONSTANT_MACRO: 3

            LOWER_SECONDARY_EDU: eduach == 2
            UPPER_SECONDARY_EDU: eduach == 3
            TERTIARY_EDU: eduach == 4

        # possible transitions & regressions. The actual list used in the
        # simulation must be defined below
        processes:
            bp: breakpoint(2002)

            expand:
                - last_non_clone_id: grpmax(id)
                - toclone: household.clone_id != -1
                - clone_id: clone(toclone)

                - is_clone: id > last_non_clone_id

                - hh_id: if(is_clone, household.clone_id, hh_id)
                - m_id: if(is_clone, mother.clone_id, m_id)
                - f_id: if(is_clone, father.clone_id, f_id)
                - partner_id: if(is_clone, partner.clone_id, partner_id)

#            test_proc:
#                code:
#                    - toto: 10
#
#            test_function:
#                args: a, b
#                code: 
#                    - result: a + b
#                    - result: result * 2
#                return: result * 2
#
#            test_small_function:
#                args: a, b
#                return: a + b
#            
#            test_call:
#                - aplusb: test_function(age, 1)
#                - show("age", age, "aplusb", aplusb)
#                
#            test_loop:
#                variables: a, b
#                sequence: age[age < 10]
#                #sequence: zip(range(10), range(10))
#                code:
#                    - show("a", a, "b", b)
#
#            test_while:
#                while: grpmin(age) < 10
#                code:
#                    - show("age", age)
#                    - age: age + 1
#
#            #XXX: embed python code instead?                    
#            while_in_proc:
#                - done: False
#                # => while is a reserved keyword and can't be used as a
#                #    variable name
#                - while:
#                    cond: not done
#                    code:
#                        - age: age + 1
#                        - show("age", age)
#                        - done: gtpmin(age) >= 10
            
#            embbeded_python:
#                done = False
#                while not done:
#                    age += 1
#                    done = min(age) >= 10
                
            test_init:
                - eduach: choice([2, 3, 4], [0.40, 0.35, 0.25])
                - weight: randint(1, 11)
#                - new('person', number=10000000,
#                      age=randint(102),
#                      gender=choice([True, False], [0.5, 0.5]),
#                      work=choice([True, False], [0.5, 0.5]),
#                      partner_id=1)

            temp_global: age + 10
            temp_global_test1:
                - temp_global: temp_global * 2
            temp_global_test2:
                - temp_global: temp_global - 10
            show_temp_global: show(temp_global)

            test_expr:
                - show("count:", grpcount())
                - show("age:", age)
                - show("age + 1:", age + 1)
                - show("age / 10:", age / 10)
                - show("100 / age:", 100 / age)
                - show("age * (1 / 2):", age * (1 / 2))
                - show("clip(age, 10, 50)", clip(age, 10, 50))

            test_attr:
                - assertEqual(age.ndim, 1)

            test_subscript:
                # with constant argument
                # take advantage of the fact that data is ordered by id
                - assertEqual(id[0], grpmin(id))

                # with expr argument
                - newborn: age[age == 0]
                - assertEqual(newborn[0], 0)
                
                # with slice
                - assertEqual(age[0:1], [age[0]])
                
                # with expr slice
                - indice: trunc(grpcount() / 2)
                - ages: age[indice:indice+10:2]
                - assertEqual(ages.__len__(), 5)
                - assertEqual(ages[0], age[indice])

            test_call:
                # without argument
                - assertEqual(age.sum(), grpsum(age))
                - assertEqual(age.std(), grpstd(age))
                - assertEqual(age.max(), grpmax(age))
                - assertEqual(age.min(), grpmin(age))

                # with constant argument
                - assertEqual(age.min(axis=-1), grpmin(age))

                # with expr argument
                - axis: 0
                - assertEqual(age.min(axis=axis), grpmin(age))

            test_periodic_globals:
                # implicit global namespace
                # -------------------------
                - fake_wemra: if(period <= 1996, 60,
                              if(period <= 1999, 61,
                              if(period <= 2002, 62,
                              if(period <= 2005, 63,
                              if(period <= 2008, 64, 65)))))
                - fake_wemra_pm1: if(period <= 1997, 60,
                                  if(period <= 2000, 61,
                                  if(period <= 2003, 62,
                                  if(period <= 2006, 63,
                                  if(period <= 2009, 64, 65)))))
                # no index
                - assertEqual(WEMRA, fake_wemra)
                # const_index 
                - assertEqual(MINR[2005], 13620.2)
                # (scalar) expr index
                - assertEqual(WEMRA[period - 1], fake_wemra_pm1)
                
                # Test that the generated variable name is the same for the
                # same global when it is used multiple time (if the period
                # is the same).
                # This is an indirect test because I cannot test this directly
                # yet (this should be a unit test instead).
                # We know numexpr will explode with a ValueError("too many
                # inputs") when there are more than 31 different variables,
                # so if this test passes it means it worked. 
                - assertEqual(WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA +
                              WEMRA + WEMRA + WEMRA + WEMRA + WEMRA + WEMRA,
                              WEMRA * 36)

                - globals_in_expr: 1.0 + MINR
                - idx_globals_in_expr: 1.0 + MINR[2002]
                - expr_idx_globals_in_expr: 1.0 + MINR[period - 1]
                - yob: randint(1900, period)
                - yop: yob + 65
                - vector_idx_globals_in_expr: 1.0 + MINR[yob + 65]
                - show("yob", yob, "yop", yop, "v", vector_idx_globals_in_expr)
                - yop2: yob + if(gender, 65, WEMRA)
                - global_in_idx: show("real yop", yop2,
                                      "minr", MINR[yob + if(gender, 65, WEMRA)])

                # explicit "periodic" namespace
                # -----------------------------
                # no index
                - assertEqual(periodic.WEMRA, fake_wemra)
                # const_index 
                - assertEqual(periodic.MINR[2005], 13620.2)
                # expr_index
                - assertEqual(periodic.WEMRA[period - 1], fake_wemra_pm1)
                - vector_idx: periodic.MINR[yob + 65]

            test_other_globals:
                # with a PERIOD column 
                - fake_intfield: if(period <= 1979, -1,
                                 if(period <= 1996, 60,
                                 if(period <= 1999, 61,
                                 if(period <= 2002, 62,
                                 if(period <= 2005, 63,
                                 if(period <= 2008, 64, 
                                 if(period <= 2010, 65, -1)))))))
                - assertEqual(othertable.INTFIELD, fake_intfield)
                # expr_index
                - assertEqual(othertable.INTFIELD[period], fake_intfield)

                - baseperiod: 1980
                - assertEqual(othertable_noperiod.INTFIELD[0], 60)
                # expr_index
                - assertEqual(othertable_noperiod.INTFIELD[period - baseperiod],
                              fake_intfield)
                # this is equivalent to INTFIELD[2002], so it is (way) out of
                # bounds but it does not fail, it simply returns "missing"
                #FIXME: it should not be allowed (ie not all global variable
                # should have this "current period if not indexed" behavior.
                - assertEqual(othertable_noperiod.INTFIELD, -1)

            test_globals_nd:
                # MIG is a 3d array: gender-age-period

                # test that MIG was loaded correctly
                - assertEqual(MIG.ndim, 3)
                - assertEqual(MIG.shape, (2, 121, 61))
                - assertEqual(MIG.dim_names, ['gender', 'age', 'period'])

                # need should have the same characteristics 
                - need: MIG * 2.5
                - assertEqual(need.ndim, 3)
                - assertEqual(need.shape, (2, 121, 61))
                - assertEqual(need.dim_names, ['gender','age', 'period'])

                # nd_mul_nd should have the same characteristics too 
                - nd_mul_nd: need * MIG
                - assertEqual(nd_mul_nd.ndim, 3)
                - assertEqual(nd_mul_nd.shape, (2, 121, 61))
                - assertEqual(nd_mul_nd.dim_names, ['gender','age', 'period'])
                
                # let us take the 2d table for this period
                # currently, we need to manually compute the index
                - base_period: 2000
                - mig_period: MIG[:,:,period - base_period]
                - assertEqual(mig_period.ndim, 2)
                - assertEqual(mig_period.shape, (2, 121))
                - assertEqual(mig_period.dim_names, ['gender', 'age'])
                - assertEqual(mig_period.pvalues.__len__(), 2)

                # should be a 2d table: gender-period
                - need_by_sex_period: need.sum(axis=1)
                - assertEqual(need_by_sex_period.ndim, 2)
                - assertEqual(need_by_sex_period.shape, (2, 61))
                # LabeledArray does not support reduction functions for now
                #- assertEqual(need_by_sex_period.dim_names, None)

                # should be a 1d table: gender
                - total_need_by_sex: need_by_sex_period.sum(axis=1)
                - assertEqual(total_need_by_sex.ndim, 1)
                - assertEqual(total_need_by_sex.shape, (2,))
                - tmp: total_need_by_sex
                
                #TODO: compare arrays directly (assertEqual uses array_equal
                #      if both instances are arrays)
#fails since I changed mig.csv
#                - assertEqual(tmp[0], 7818940)
#                - assertEqual(tmp[1], 7692870)
                
                # for current period, a 1d table: gender
                # currently, we need to manually compute the index
                - need_by_sex: need_by_sex_period[:,period - base_period]
                - assertEqual(need_by_sex.ndim, 1)
                - assertEqual(need_by_sex.shape, (2,))
#                - show(need_by_sex)

            test_macro:
                - ischild: age < 18
                - test_nonmacro1: show(grpsum(ischild))
                - test_macro1: show(grpsum(ISCHILD))
#                - breakpoint(2002)

                - age: age + 1

                - test_nonmacro2: show(grpsum(ischild))
                - show("test grpsum:", grpsum(ischild))
                - test_macro2: show(grpsum(ISCHILD))

                - show('male students', grpcount(MALE and LOWER_SECONDARY_EDU))

#                - show('expr wh missing parenthesis', grpcount(age < 15 & eduach == 2))
                # equivalent to grpcount(age < (15 & eduach) == 2)
                # equivalent to grpcount((age < (15 & eduach)) *and* ((15 & eduach) == 2))
                # calls __nonzero__ on the first part (age < (15 & eduach))
                - show(groupby(eduach, gender))

            agegroup: if(age < 50, 5 * trunc(age / 5), 10 * trunc(age / 10))

            test_align:
                - num_all: grpcount()
                - num_women: grpcount(not gender)
                - num_men: grpcount(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align(age,
                                     expressions=[gender],
                                     possible_values=[[False, True]],
                                     proportions=[0.1, 0.2])
                - num_aligned: grpcount(int_aligned)
                - num_aligned_women: grpcount(int_aligned and not gender)
                - num_aligned_men: grpcount(int_aligned and gender)
                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that older individuals are taken first
                - assertTrue(grpmax(age, filter=gender and not int_aligned)
                             <=
                             grpmin(age, filter=gender and int_aligned))
                - assertTrue(grpmax(age, filter=not gender and not int_aligned)
                             <=
                             grpmin(age, filter=not gender and int_aligned))

                # manual alignment on a float column (with nan)
                # ---------------------------------------------
                - nan_age: if(age < 10, nan, age * 1.0)
                - assertEqual(grpcount(nan_age != nan_age), grpcount(age < 10))
                - float_aligned: align(nan_age,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: grpcount(float_aligned)
                - num_aligned_women: grpcount(float_aligned and not gender)
                - num_aligned_men: grpcount(float_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that nan are chosen first
                # we have two different scenarii:
                # 1) we have more "nan" than we need
                #    => we check that all taken are "nan"
                # 2) or we have less "nan" than we need
                #    => we check that all "nan" are taken / aligned
                # and we have to check separately for men and women

                - isnan: nan_age != nan_age

                # women

                # more than 10% women are "nan"
                - morenan: grpcount(not gender and isnan) > num_women * 0.1
                - all_taken_nan: grpmin(isnan,
                                        filter=not gender and float_aligned)
                - all_nan_taken: grpmin(float_aligned,
                                        filter=not gender and isnan)
                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # men

                # more than 20% men are "nan"
                - morenan: grpcount(gender and isnan) > num_men * 0.2
                - all_taken_nan: grpmin(isnan, filter=gender and float_aligned)
                - all_nan_taken: grpmin(float_aligned, filter=gender and isnan)

                - assertTrue(if(morenan, all_taken_nan, all_nan_taken))

                # manual alignment with a constant
                # --------------------------------
                - const_aligned: align(False, filter=age < 10,
                                       expressions=[gender],
                                       possible_values=[[False, True]],
                                       proportions=[0.1, 0.2])
                - num_aligned: grpcount(const_aligned)
                - num_aligned_women: grpcount(const_aligned and not gender)
                - num_aligned_men: grpcount(const_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(grpmax(id, filter=gender and (age < 10) and
                                               not const_aligned)
                             <=
                             grpmin(id, filter=gender and const_aligned))
                - assertTrue(grpmax(id, filter=not gender and (age < 10) and
                                               not const_aligned)
                             <=
                             grpmin(id, filter=not gender and const_aligned))

                # manual alignment with no score
                # ------------------------------
                - none_aligned: align(filter=age < 10,
                                      expressions=[gender],
                                      possible_values=[[False, True]],
                                      proportions=[0.1, 0.2])
                - num_aligned: grpcount(none_aligned)
                - num_aligned_women: grpcount(none_aligned and not gender)
                - num_aligned_men: grpcount(none_aligned and gender)

                - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # check that individuals with higher ids are chosen first
                - assertTrue(grpmax(id, filter=gender and (age < 10) and
                                               not none_aligned)
                             <=
                             grpmin(id, filter=gender and none_aligned))
                - assertTrue(grpmax(id, filter=not gender and (age < 10) and
                                               not none_aligned)
                             <=
                             grpmin(id, filter=not gender and none_aligned))

                # manual alignment with individuals in missing categories
                # -------------------------------------------------------

                - miss_aligned: align(filter=id < 100,
                                      expressions=[20 * trunc(age / 20)],
                                      possible_values=[[0, 20, 60, 80, 100]],
                                      proportions=[0.1, 0.1, 0.1, 0.1, 0.1])
                - num_aligned: grpcount(miss_aligned)
                - assertTrue(num_aligned - 0.1 * num_all < 1.0)

                # alignment with an implicit filter
                # ---------------------------------

                # the "dead" variable is also used for the cleanup process
                - dead: if(gender,
                           align(take=age > 95, leave=ISCHILD,
                                 fname='al_p_dead_m.csv'),
                           align(take=age > 95, leave=ISCHILD,
                                 fname='al_p_dead_f.csv'))

                - assertEqual(grpcount(not dead and (age > 95)), 0)
                - assertEqual(grpcount(dead and ISCHILD), 0)

                # 3d alignment (gender, age, period)
                # ----------------------------------
                - dead2: align(take=age > 95, leave=ISCHILD,
                               fname='al_p_dead.csv')

                - assertTrue(grpcount(dead != dead2) <= 105)
                
                # 2d alignment with period not last
                # ---------------------------------
                - percent_f: if(period <= 2002, 0.2,
                             if(period <= 2003, 0.3, 0.4))
                - percent_m: percent_f + 0.1
                - aligned: align(fname='al_p_period_notlast.csv')

                - theoric_aligned_f: trunc(grpcount(not gender) * percent_f)
                - theoric_aligned_m: trunc(grpcount(gender) * percent_m)
                - diff_f: grpcount(aligned and not gender) - theoric_aligned_f  
                - diff_m: grpcount(aligned and gender) - theoric_aligned_m  
                - assertTrue((0 <= diff_f) and (diff_f <= 1))
                - assertTrue((0 <= diff_m) and (diff_m <= 1))
                - show('diff_f', diff_f, 'diff_m', diff_m)

                # 1d alignment (period)
                # ---------------------
                - period_only: align(fname='al_p_period_only.csv')
                - num_aligned: grpcount(period_only)
                - target_percent: if(period == 2002, 0.2,
                                  if(period == 2003, 0.3,
                                  0.4))
                - assertTrue(num_aligned - target_percent * num_all < 1.0)

                # 1d alignment (other than period)
                # --------------------------------
                - by_gender: align(fname='al_p_one_dim.csv')

                - num_aligned: grpcount(by_gender)
                - num_aligned_women: grpcount(by_gender and not gender)
                - num_aligned_men: grpcount(by_gender and gender)

                - assertTrue(num_aligned_women - 0.2 * num_women < 1.0)
                - assertTrue(num_aligned_men - 0.3 * num_men < 1.0)
                - assertEqual(num_aligned_women + num_aligned_men, num_aligned)

                # align using a temporary variable
                - temp: age + 1

                # these do not produce exactly the same values because of the
                # way we correct for "fractional persons" with a probability of
                # adding one person. However the difference should be <= than
                # the number of alignment categories.
                - var_aligned: align(fname='al_p_dead_m.csv')
                - temp_aligned: align(fname='al_p_temp.csv')
                - expr_aligned: align(fname='al_p_dead_m.csv',
                                      expressions=[age + 1 - (age + 1) / (age + 1), period])
                - assertTrue(grpcount(temp_aligned != var_aligned) <= 105)
                - assertTrue(grpcount(expr_aligned != var_aligned) <= 105)

                # fixed proportion
                # ----------------
                - fixed_percent_aligned: align(proportions=0.1)
                - num_aligned: grpcount(fixed_percent_aligned)
                - assertTrue(abs(num_aligned - trunc(num_all * 0.1)) <= 1)
                
                # expr proportion
                # ---------------
                - percent: if(period == 2002, 0.1, 0.2) 
                - expr_percent_aligned: align(proportions=percent)
                - num_aligned: grpcount(expr_percent_aligned)
                - target_num: if(period == 2002, 
                                 trunc(0.1 * num_all),
                                 trunc(0.2 * num_all))
                - assertTrue(abs(num_aligned - target_num) <= 1)

                # expr ndarray
                # ------------

                # compute % of men for each age
                # Note that we cannot use groupby(age, filter=gender) because
                # in that case we might have age categories missing whereas
                # we want them to be empty instead.  
                - men_by_age: groupby(age, expr=grpcount(gender))
                - men_prop_by_age: men_by_age / groupby(age)

                - expr_ndarray_aligned: align(proportions=men_prop_by_age)
                - num_aligned: grpcount(expr_ndarray_aligned)
                # this is correct (and not modulo 1 for each category like
                # other alignment tests) because for each age:
                # expected = len(member_indices) * proportion
                # where len(member_indices) = grpcount(age==x) 
                #                             grpcount(age==x and gender)
                #   and proportion          = ---------------------------
                #                             grpcount(age==x)
                #            grpcount(age==x) * grpcount(age==x and gender)
                # expected = ------------------------------------------------
                #            grpcount(age==x)
                #          = grpcount(age==x and gender)
                # and thus expected == int(expected)
                - assertEqual(num_aligned, grpcount(gender))
                - assertEqual(groupby(age, filter=expr_ndarray_aligned),
                              groupby(age, filter=gender))
                              
                # sidewalk method 
                # ------------
                # - int_aligned_SW: align(0.2,
                                     # expressions=[gender],
                                     # possible_values=[[False, True]],
                                     # proportions=[0.1, 0.2], method='sidewalk')
                # - num_aligned: grpcount(int_aligned_SW)
                # - num_aligned_women: grpcount(int_aligned_SW and not gender)
                # - num_aligned_men: grpcount(int_aligned_SW and gender)
                # - assertTrue(num_aligned_women - 0.1 * num_women < 1.0)
                # - assertTrue(num_aligned_men - 0.2 * num_men < 1.0)
                # - assertEqual(num_aligned_women + num_aligned_men, num_aligned)
                # - show( 'nb aligned', grpcount(int_aligned))
                # - show( 'nb aligned SW', grpcount(int_aligned_SW))
                
                
            test_align_abs:
                - num_all: grpcount()
                - num_women: grpcount(not gender)
                - num_men: grpcount(gender)

                # manual alignment on an integer column
                # -------------------------------------
                - int_aligned: align_abs(age, 
                                         [10, 20],
                                         expressions=[gender],
                                         possible_values=[[False, True]])
                - assertEqual(grpcount(int_aligned and not gender), 10)
                - assertEqual(grpcount(int_aligned and gender), 20)
                - assertEqual(grpcount(int_aligned), 30)

                # check that older individuals are taken first
                - assertTrue(grpmax(age, filter=gender and not int_aligned)
                             <=
                             grpmin(age, filter=gender and int_aligned))
                - assertTrue(grpmax(age, filter=not gender and not int_aligned)
                             <=
                             grpmin(age, filter=not gender and int_aligned))

                # external file
                # -------------
                - by_gender: align_abs(0, 'al_p_absolute.csv')

                - assertEqual(grpcount(by_gender), 50)
                - assertEqual(grpcount(by_gender and not gender), 20)
                - assertEqual(grpcount(by_gender and gender), 30)

                # external file, overridden expressions
                # -------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       expressions=[not gender])

                - assertEqual(grpcount(by_gender), 50)
                - assertEqual(grpcount(by_gender and not gender), 30)
                - assertEqual(grpcount(by_gender and gender), 20)

                # external file, overridden possible_values
                # -----------------------------------------
                - by_gender: align_abs(0, 'al_p_absolute.csv',
                                       possible_values=[[True, False]])

                - assertEqual(grpcount(by_gender), 50)
                - assertEqual(grpcount(by_gender and not gender), 30)
                - assertEqual(grpcount(by_gender and gender), 20)

            check_align_link:
                - show(groupby(age, gender, filter=household.aligned))
#                - clone_id: clone(household.aligned,
#                                  hh_id=household.clone_id)

            test_logit_regr:
                # equivalent to uniform() > 0.5
                - simple: logit_regr(0.0)
                - fixed_percent: logit_regr(0.0, align=0.5)
                - with_file: logit_regr(0.0, align='al_p_one_dim.csv')

            test_cont_regr:
                # expr only
                - assertEqual(cont_regr(2.4 + 0.22 * age),
                              2.4 + 0.22 * age)

                # with explicit filter
                - value: cont_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == 2.4 + 0.22 * age,
                            value != value)
                - assertEqual(grpcount(check), grpcount())
                
                # with implicit filter
                - assertEqual(if(gender, cont_regr(2.4 + 0.22 * age), 42.0),
                              if(gender, 2.4 + 0.22 * age, 42.0))

                # with both implicit and explicit filter
                - value: if(gender,
                            cont_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == 2.4 + 0.22 * age,
                               value != value),
                            value == 42.0)
                - assertEqual(grpcount(check), grpcount())

                # with error_var
                - err: normal()
                - assertEqual(cont_regr(2.4 + 0.22 * age, error_var='err'),
                              2.4 + 0.22 * age + err)

                # with mult
                - value: cont_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (value - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - grpavg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - grpstd(check)) < 0.1)

            test_log_regr:
                # expr only
                - assertEqual(log_regr(2.4 + 0.22 * age),
                              exp(2.4 + 0.22 * age))

                # with explicit filter
                - value: log_regr(2.4 + 0.22 * age, filter=gender)
                # we can't use assertEqual(value, xxx) because arrays with nans
                # do not compare equal
                - check: if(gender,
                            value == exp(2.4 + 0.22 * age),
                            value != value)
                - assertEqual(grpcount(check), grpcount())
                
                # with implicit filter
                - assertEqual(if(gender, log_regr(2.4 + 0.22 * age), 42),
                              if(gender, exp(2.4 + 0.22 * age), 42))

                # with both implicit and explicit filter
                - value: if(gender,
                            log_regr(2.4 + 0.22 * age, filter=age > 20),
                            42.0)
                - check: if(gender,
                            if(age > 20,
                               value == exp(2.4 + 0.22 * age),
                               value != value),
                            value == 42.0)
                - assertEqual(grpcount(check), grpcount())

                # with error_var
                - err: normal()
                - assertEqual(log_regr(2.4 + 0.22 * age, error_var='err'),
                              exp(2.4 + 0.22 * age + err))

                # with mult
                - value: log_regr(2.4 + 0.22 * age, mult=2)
                # this should yield a simple normal random distribution
                - check: (log(value) - (2.4 + 0.22 * age)) / 2

                # the average of a normal is mu (=0)
                - mu: 0
                - assertTrue(abs(mu - grpavg(check)) < 0.1)
                # the stddev of a normal is sigma (=1)
                - sigma: 1
                - assertTrue(abs(sigma - grpstd(check)) < 0.1)

            test_uninitialized_var: uninitialized_var
            uninitialized_var: True

            test_new:
                # with no filter/parent (number=) 
                - new_id: new('person', number=10,
                              age=0,
                              gender=choice([True, False], [0.51, 0.49]))

                # with explicit filter
                - givebirth: not gender and (age >= 16) and (age <= 50)
                - new_id: new('person', filter=givebirth and partner_id != -1,
                              age=0,
                              partner_id=-1,
                              hh_id=hh_id,
                              m_id=id,
                              f_id=partner.id,
                              gender=choice([True, False], [0.51, 0.49]))

                # with implicit filter
                                    # unknown father (even if the mother has a 
                                    # a partner)
                - new_id: if(givebirth,
                             if(age < 25,
                                new('person',
                                    age=0,
                                    partner_id=-1,
                                    hh_id=hh_id,
                                    m_id=id,
                                    f_id=-1,
                                    gender=choice([True, False], [0.51, 0.49])),
                                new('person',
                                    age=0,
                                    partner_id=-1,
                                    hh_id=hh_id,
                                    m_id=id,
                                    f_id=partner.id,
                                    gender=logit_regr(0.0))),
                             -1)

            test_o2m:
                # countlink
                - nch: countlink(children)
                - nch_012: countlink(children, age <= 12)
                
                # sumlink
                - ch_012_age_sum: sumlink(children, age, age <= 12)
                - ch_012_age2_sum: sumlink(children, age * 2, age <= 12)

                # with a scalar
                - assertEqual(sumlink(children, 10), nch * 10)

                - ch_012_age_avg: avglink(children, age, age <= 12)
                - ch_minage: minlink(children, age)
                - ch_maxage: maxlink(children, age)
                - show(dump(nch, nch_012, ch_012_age_sum, ch_012_age2_sum,
                            ch_012_age_avg, filter=(nch > 0) and (id < 100)))

            test_mixed_links:
                - show('mother vs step-mother:', mother.age, partner.mother.age)
                - show('other sex step-parent:',
                        where(gender, partner.mother.age, partner.father.age))
                - show('age vs age if married:', age, partner.partner.age)
                - show('mother.partner.age:', mother.partner.age,
                       'father.age:', father.age)
                - show('hh.id:', household.id,
                       'hh.id+1:', household.get(id + 1),
                       'edu:', eduach,
                       'num persons:', household.get(countlink(persons)),
                       'num high edu:', household.get(countlink(persons, eduach == 4)))

#            test_extra_comma:
#                - show('test extra colon'),

            test_predictor1:
                predictor: plop
                expr: if(age < 10, age ** 3, age ** 2)
            test_predictor2:
                predictor: plop
                expr: if(age >= 10, 100, plop)

            test_predictor3:
                - a:
                    predictor: plop2
                    expr: if(age < 10, age ** 3, age ** 2)
                - b:
                    predictor: plop2
                    expr: if(age >= 50, 100, plop2)
                - show(plop2)

            test_clone:
                - clone(filter = age == 95,
                        f_id = id,
                        m_id = id,
                        nch = household.get(countlink(persons)))

            marriage:
                - married: partner_id != -1

                - to_marry: (age >= 18) and (age <= 90) and not married
                - avg_age_men: grpavg(age, filter=to_marry and gender)
                - difficult_match: if(to_marry and not gender,
                                      abs(age - avg_age_men),
                                      nan)
                - workless: not work
# commented to make the test faster
#                                      + 0.0015 * abs(household.num_persons - other.household.num_persons)
#                                      - 0.0015 * abs(household.get(countlink(persons, age < 18))
#                                                     - other.household.get(countlink(persons, age < 18)))
                - partner_id:
                    if(to_marry,
                       matching(set1filter=not gender,
                                set2filter=gender,
                                score=- 0.4893 * other.age
                                      + 0.0131 * other.age ** 2
                                      - 0.0001 * other.age ** 3
                                      + 0.0467 * (other.age - age)
                                      - 0.0189 * (other.age - age) ** 2
                                      + 0.0003 * (other.age - age) ** 3
                                      - 0.9087 * (other.work and workless)
                                      - 1.3286 * (other.workless and not workless)
                                      - 0.6549 * (other.work and work)
                                      - 0.7939 * ((other.eduach == 3) and TERTIARY_EDU)
                                      - 1.4128 * ((other.eduach == 2) and TERTIARY_EDU)
                                      - 0.8984 * ((other.eduach == 4) and UPPER_SECONDARY_EDU)
                                      - 1.5530 * ((other.eduach == 4) and LOWER_SECONDARY_EDU)
                                      - 0.5451 * ((other.eduach == 2) and LOWER_SECONDARY_EDU),
                                orderby=difficult_match),
                       partner_id)

                - just_married: to_marry and (partner_id != -1)

                - newhousehold: new('household', filter=just_married and not gender,
                                    start_period=period)
                - hh_id: if(just_married,
                            if(gender, partner.newhousehold, newhousehold),
                            hh_id)

            test_compound:
                - show(min(age, 10))
                - show(grpmax(min(age, 10)))

                - assertEqual(grpmax(min(age, 10)), 10)
                - assertEqual(grpmin(max(age, 20)), 20)

            test_lag:
                - global: show(MINR)
                - global_t: show(MINR[period])
                
                - lagglobal: show(lag(MINR))
                - lagglobal_period: show(lag(MINR[period]))
                - lagglobal_attr: show(lag(MINR.shape))
                - global_t_1: show(MINR[period - 1])
                
                - global_t_age: show(MINR[period - age])
                - lagglobal_expr: show(lag(MINR, grpmin(age) + 1))

                # does not work yet. It needs the context to accept a vector
                # of periods instead of a single period
#                - lagglobal_expr_multi: show(lag(MINR, age))

                - lag_age_subscript: show(lag(age[0]))

                - lagavg: show(lag(grpavg(age)))
                - avglag: show(grpavg(lag(age)))

                # this fails if we cloned adults: they are missing in last
                # period but have an age != 0 this period
#                - assertEqual(lag(age, missing=0), if(age == 0, 0, age - 1))

                - num_birth: grpcount(age == 0)
                # fails with clones
#                - assertEqual(grpcount(lag(age) == -1), num_birth)
                - assertEqual(grpcount(lag(age, missing=0) == -1), 0)

                - num1yearold: grpcount(age == 1)
#                - assertEqual(grpcount(lag(age, missing=0) == 0),
#                              num1yearold + num_birth)

                - assertEqual(lag(age, 2), lag(lag(age)))

                # for clones lag(age, 2) is -1, even if the parent of the clone
                # is alive in period - 2
                - cloned: (m_id == f_id) and (m_id != -1)
#                - assertEqual(if(cloned,
#                                 age - 2,
#                                 lag(age, 2)),
#                              if(period > 2002,
#                                 if(age >= 2, age - 2, -1),
#                                 -1))

            test_duration:
                - show("age > 10", duration(age > 10))
                - show("max(d, 2)", max(duration(age > 10), 2))

                # with a simple boolean variable
                # modify work so that it is not constant for all periods
                - work: choice([False, True])
                # this is just a way to save the work variable
                - work_backup: work and work
                - dur_work: duration(work)
                # check that work was not modified (used to be the case)
                - assertEqual(work, work_backup)
                # check that dur_work is correct
                - assertEqual(dur_work == 0, not work)
                - assertEqual(dur_work == 1, work and not lag(work))
                - assertEqual(dur_work == 2,
                              work and lag(work) and not lag(work, 2))
                - assertEqual(dur_work > 2,
                              work and lag(work) and lag(work, 2))

            test_dump_init:
                - empty_file: csv(fname='empty_file.csv')
                - one_line_header: csv('period', 'id', 'age', fname='person_ages.csv')
                - two_line_header: csv(['average', 'gini'],
                                       ['-', 'inequality coefficient'],
                                       fname='person_age_aggregates.csv')

            test_dump:
                - expr: csv(dump(gender, age, partner_id, partner.age),
                            suffix='partner_ages')
                - full: csv(dump(), suffix='full')
                - twodumps: csv(dump(gender, age, filter=not gender),
                                'and now something completely different',
                                dump(gender, age, filter=gender),
                                suffix='split_ages')
                # no fname nor suffix
                - csv(dump(age))
                - fname: csv(dump(age), fname='person_ages_{period}.csv')
                # append
                - csv(dump(period, id, age, filter=id < 10, header=False),
                      fname='person_ages.csv', mode='a')
                # test show
                - show(dump(gender, age, filter=id < 10))
                # aggregate and filter (0.6 * is important, otherwise we don't
                # get a 0-d ndarray back, which was the cause of a bug)
                - median_age: 0.6 * grpmedian(age)
                - csv(dump(age, grpavg(age), age > grpavg(age), median_age,
                           filter=id < 10),
                      suffix='aggregate_filter')

            test_csv:
                - expr: csv(grpavg(age),
                            fname='person_age_aggregates.csv', mode='a')
                - exprs: csv(grpavg(age), grpgini(age),
                             fname='person_age_aggregates.csv', mode='a')

                # empty groupby
                - csv(groupby(gender, filter=age > 200))

            cleanup: remove(lag(dead))

            test_o2m_aggregate: show(grpavg(countlink(children)))

            test_grpsum:
                # simple
                - population_age: grpsum(age)
                
                # explicit filter
                - males_age: grpsum(age, filter=MALE)
                - assertEqual(males_age, grpsum(age * MALE))
                - females_age: grpsum(age, filter=FEMALE)
                - assertEqual(females_age, grpsum(age * FEMALE))
                - assertEqual(males_age + females_age, population_age)
                
                # implicit filter
                # assign to each man the sum of men ages and to each woman
                # the sum of women ages
                - filtered: if(MALE, grpsum(age), grpsum(age))
                - assertEqual(grpcount(filtered == males_age),
                              grpcount(MALE))
                - assertEqual(grpcount(filtered == females_age),
                              grpcount(FEMALE))
                              
                # with missing
                - assertEqual(grpsum([1, -1, 2]), 3)
                - assertEqual(grpsum([1.0, nan, 2.0]), 3.0)
                
                # with missing but skip_na=False
                - assertEqual(grpsum([1, -1, 2], skip_na=False), 2)
                - withnan: grpsum([1.0, nan, 2.0], skip_na=False)
                - assertTrue(withnan != withnan)

                # with missing and filter
                - assertEqual(grpsum(if(age > 10, -1, age), filter=gender),
                              grpsum(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(grpsum(if(age > 10, nan, f_age), filter=gender),
                              grpsum(f_age, filter=age <= 10 and gender))

                # bool expr
                - sum_bool: grpsum([False, True, True])
                - assertEqual(sum_bool, 2)
                
                # scalar
                # currently fails
#                - assertEqual(grpsum(2), 2 * grpcount())
                - assertEqual(grpsum(2, filter=MALE), 2 * grpcount(MALE))

            test_grpavg:
                # simple
                - assertEqual(grpavg(age), grpsum(age) / grpcount())

                # explicit filter
                - assertEqual(grpavg(age, filter=MALE),
                              grpsum(age, filter=MALE) / grpcount(MALE))
                - assertEqual(grpavg(age, filter=FEMALE),
                              grpsum(age, filter=FEMALE) / grpcount(FEMALE))

                # with missing
                - assertEqual(grpavg([1.0, nan, 3.0]), 2.0)
                - assertEqual(grpavg([1, -1, 3]), 2.0)
                
                # with missing but skip_na=False
                - assertEqual(grpavg([1, -1, 3], skip_na=False), 1.0)
                - withnan: grpavg([1.0, nan, 3.0], skip_na=False)
                - assertTrue(withnan != withnan)

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(grpavg(if(age > 10, -1, age), filter=gender),
                              grpavg(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(grpavg(if(age > 10, nan, f_age), filter=gender),
                              grpavg(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)
                
                # bool expr
                - assertEqual(grpavg([False, True, True, False]), 0.5)

            test_grpstd:
                # bool expr
                - assertEqual(grpstd([False, True, True, False]), 0.5)

            test_grpmin:
                # simple scalars
                - assertEqual(grpmin([2, 1, 3]), 1)
                - assertEqual(grpmin([2.0, 1.0, 3.0]), 1.0)

                # simple column
                - assertEqual(grpmin(age), 0)

                # explicit filter
                - assertEqual(grpmin(age, filter=age >= 10), 10)

                # with na
                - assertEqual(grpmin([3, -1, 2]), 2)
                - assertEqual(grpmin([3.0, nan, 2.0]), 2.0)

                # with na not skipping
                - assertEqual(grpmin([3, -1, 2], skip_na=False), -1)
                - whnan: grpmin([3.0, nan, 2.0], skip_na=False)
                - assertTrue(whnan != whnan)

                # with na and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(grpmin(if(age > 10, -1, age), filter=gender),
                              grpmin(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(grpmin(if(age > 10, nan, f_age), filter=gender),
                              grpmin(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_grpmedian:
                # simple without filter
                - median_age: grpmedian(age)
                - num_young: grpcount(age < median_age)
                - num_median: grpcount(age == median_age)
                - num_old: grpcount(age > median_age)
                - num_total: grpcount()

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

                # scalar (there is not much point but it should not crash)
                - median_age2: grpmedian(median_age)
                - assertEqual(median_age, median_age2)

                # with an explicit filter
                - median_age: grpmedian(age, filter=gender)
                - num_young: grpcount(gender and (age < median_age))
                - num_median: grpcount(gender and (age == median_age))
                - num_old: grpcount(gender and (age > median_age))
                - num_total: grpcount(gender)

                - assertTrue(num_young <= num_total / 2)
                - assertTrue(num_old <= num_total / 2)
                - assertEqual(num_young + num_median + num_old, num_total)

            test_grppercentile:
                # without filter
                - age_10p: grppercentile(age, 10)
                - num_young: grpcount(age < age_10p)
                - num_10p: grpcount(age == age_10p)
                - num_old: grpcount(age > age_10p)
                - num_total: grpcount()

                # the + 1 are necessary in case the Nth value is between two
                # different values because in that case, the percentile is a
                # linear approximation of both values, and thus the number of
                # values smaller can be 1 more. Note that if we are between
                # two indices but the values at those two indices is the same
                # we do not have a problem, that is why this problem only
                # triggers rarely in our test because many individuals have
                # the same age.
                # >>> a = [0, 1, 2, 3, 4]
                # >>> np.percentile(a, 25)
                # 1.0
                # >>> np.sum(a < 1.0)
                # 1
                # >>> np.percentile(a, 26)
                # 1.04
                # >>> np.sum(a < 1.04)
                # 2 
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

                # with a filter
                - age_10p: grppercentile(age, 10, filter=gender)
                - num_young: grpcount(gender and (age < age_10p))
                - num_10p: grpcount(gender and (age == age_10p))
                - num_old: grpcount(gender and (age > age_10p))
                - num_total: grpcount(gender)
                - assertTrue(num_young <= (num_total / 10) + 1)
                - assertTrue(num_old <= (num_total * 90 / 100) + 1)
                - assertEqual(num_young + num_10p + num_old, num_total)

            test_grpgini:
                # simple expr
                - assertEqual(grpgini([1, 1, 1]), 0)
                - assertEqual(grpgini([0, 0, 0, 1]), 0.75)
                - assertEqual(grpgini([1.0, 0.0, 1.0, 1.0]), 0.25)
                
                # with missing values
                - assertEqual(grpgini([0, -1, 1, 0, 0, -1]), 0.75)
                - assertEqual(grpgini([0.0, nan, 1.0, 0.0, 0.0, nan]), 0.75)

                # with missing values without skipping
                - assertEqual(grpgini([0, -1, 1, 1, 0], skip_na=False), 2.0)
                - wh_nan: grpgini([0.0, nan, 1.0, 0.0, nan], skip_na=False)
                - assertTrue(wh_nan != wh_nan)

                # boolean expr
                - assertEqual(grpgini([False, False, False, True]), 0.75)

                # with an explicit filter
                - show('grpgini(age)', grpgini(age))
                - show('grpgini(age) by sex:',
                       grpgini(age, filter=MALE),
                       '/',
                       grpgini(age, filter=FEMALE))

                # with missing and filter
                # this is just a way to save the gender variable
                - gender_backup: gender and gender
                - assertEqual(grpgini(if(age > 10, -1, age), filter=gender),
                              grpgini(age, filter=age <= 10 and gender))
                - f_age: age * 1.0
                - assertEqual(grpgini(if(age > 10, nan, f_age), filter=gender),
                              grpgini(f_age, filter=age <= 10 and gender))
                # check that gender was not modified (used to be the case)
                - assertEqual(gender, gender_backup)

            test_choice:
                - intchoice: choice([0, 5, 10], [0.1, 0.2, 0.7])
                - num0: grpcount(intchoice == 0)
                - num5: grpcount(intchoice == 5)
                - num10: grpcount(intchoice == 10)
                - num_total: grpcount()
                - assertEqual(num0 + num5 + num10, num_total)

                # test choices and probablities being expressions
                - zero: grpavg(age) - grpavg(age)

                - p0: zero + 0.1
                - p1: zero + 0.3

                - fchoice: choice([zero, zero + 1.0, zero + 2.0], [p0, p1, 1.0 - p0 - p1])

                - num0: grpcount(fchoice == 0.0)
                - num1: grpcount(fchoice == 1.0)
                - num2: grpcount(fchoice == 2.0)
                - assertEqual(num0 + num1 + num2, num_total)
                # this assertion can fail but it should occur pretty rarely
                - assertTrue((num0 < num1) and (num1 < num2))
                
                - show(groupby(choice([zero, zero + 1.0], [p0, 1.0 - p0]),
                               choice([0, 1], [0.3, 0.7]),
                               choice([0, 1])))

            test_groupby:
                # 1 dim
                - by_gender: groupby(gender)
                - assertEqual(by_gender,
                              [grpcount(not gender), grpcount(gender)])

                # 2 dim
                - by_agegroup_gender: groupby(agegroup, gender)
                - assertEqual(by_agegroup_gender.ndim, 2)
                - assertEqual(by_agegroup_gender.dim_names,
                              ['agegroup', 'gender'])
                - assertTrue(by_agegroup_gender.row_totals.__len__() > 0)
                - assertEqual(by_agegroup_gender.col_totals,
                              [grpcount(not gender),
                               grpcount(gender),
                               grpcount()])
                - assertEqual(by_agegroup_gender[0],
                              [grpcount(agegroup == -1 and not gender),
                               grpcount(agegroup == -1 and gender)])

                # fails as expected, but if we can fix this, it would be nice
#                - show('groupby scalar', groupby(True, gender))
                # this is currently broken
#                - show('groupby scalar', groupby(grpavg(age), gender))

                # grouping by expressions (not only simple columns)
                - show(groupby(round(logit_score(0.0), 1)))
                - show('groupby global', groupby(if(gender, 65, WEMRA), gender))

                # with expr=
                - explicit_count: groupby(gender, expr=grpcount())
                - assertEqual(explicit_count,
                              [grpcount(not gender), grpcount(gender)])

                - avg_age: groupby(gender, expr=grpavg(age))
                - assertEqual(avg_age, [grpavg(age, filter=not gender),
                                        grpavg(age, filter=gender)])
                
                - show('grpmin', groupby(agegroup, expr=grpmin(age)))
                - temp_scalar: grpavg(age)
                - show('wh scalar variable', groupby(agegroup, expr=temp_scalar * grpmin(age)))

                # with expr= and filter
                - avg_age_work: groupby(gender, expr=grpavg(age), filter=work)
                - assertEqual(avg_age_work,
                              [grpavg(age, filter=work and not gender),
                               grpavg(age, filter=work and gender)])
                - assertEqual(avg_age_work.row_totals,
                              [grpavg(age, filter=work)])
                # expr=id
                - ids_by_gender: groupby(gender, expr=id, filter=id < 20)
                - assertEqual(ids_by_gender[0], id[id < 20 and not gender])
                - assertEqual(ids_by_gender[1], id[id < 20 and gender])

                # expr=id with the same number in each category (because in
                # that case dtype is int, instead of object) 
                - ids_by_id: groupby(id >= 10, expr=id, filter=id < 20)
                - assertEqual(ids_by_id[0], id[id < 10])
                - assertEqual(ids_by_id[1], id[id >= 10 and id < 20])

                # expr=scalar
                - ten_by_gender: groupby(gender, expr=10)
                - assertEqual(ten_by_gender, [10, 10])

                # empty result
                - empty: groupby(gender, filter=age > 200)
                - show(empty)
                - assertEqual(empty, [])
                - empty_percent: groupby(gender, filter=age > 200,
                                         percent=True)
                - assertEqual(empty_percent, [])
                - show(empty_percent)

                # ...
                - num_persons2_percent: show(groupby(agegroup, gender, percent=True))
                
                - num_persons_weight_percent: show(groupby(agegroup, gender, expr=grpsum(weight), percent=True))
                - num_persons_csv: csv(groupby(agegroup, gender), suffix='groupby')
                - num_persons3: show(groupby(agegroup, dead, gender))

                - ismarried: partner_id != -1
                - num_persons3t: show(groupby(agegroup, gender, ismarried))
                - num_alive: show(groupby(agegroup, gender,
                                          expr=grpcount(not dead)))
                - num_married: show(groupby(agegroup, gender,
                                            expr=grpcount(ismarried)))
                - num_widows: show(groupby(agegroup, gender,
                                           expr=grpcount(partner.dead)))
                - num_bad_partner: show(groupby(agegroup, gender,
                                                expr=grpcount((partner_id != -1) and (partner.partner.id != id))))
                - agediff: show(groupby(agegroup, gender,
                                        expr=grpavg(age - if(partner.age == -1, nan, partner.age))))
#                                        expr=grpavg(abs(age - if(partner.age == -1, nan, partner.age)))))
#                                        expr=grpsum(countlink(children)) / grpsum(not dead)))
#                                        expr=grpavg(nch)))
#                - minmax_age: show(groupby(id / 100, gender, expr=grpmax(age) - grpmin(age)))

                # groupby in expressions
                # ----------------------
                - simple_expr: by_agegroup_gender * 2  
                - assertEqual(simple_expr.ndim, 2)
                - assertEqual(simple_expr.dim_names, ['agegroup', 'gender'])
                - assertEqual(simple_expr.row_totals, None)
                - assertEqual(simple_expr.col_totals, None)
                
                # We cannot use groupby(age, filter=gender) because in that
                # case we might have missing age categories whereas we want
                # them to be empty instead.  
                - men_by_age: groupby(age, expr=grpcount(gender))
                - assertEqual(men_by_age.dim_names, ['age'])
                - by_age: groupby(age)
                - assertEqual(by_age.dim_names, ['age'])
                - men_prop_by_age: men_by_age / by_age
                - assertEqual(men_prop_by_age.dim_names, ['age'])
                - assertEqual(men_prop_by_age,
                              groupby(age, expr=grpcount(gender) / grpcount()))

                # this does not trigger the same path than men_prop_by_age
                # (even though both go through ne), but this one creates hidden
                # temporary variables in EvaluableExpression.as_simple_expr
                # while the other does not
                - men_prop2: groupby(age, expr=grpcount(gender)) / groupby(age)
                - assertEqual(men_prop2.dim_names, ['age'])

                - min_count_by_gender: grpmin(by_agegroup_gender, axis=0)
                - qshow(min_count_by_gender)
                - assertEqual(min_count_by_gender.shape, (2,))
                - assertEqual(min_count_by_gender.dim_names, None)
                - assertEqual(min_count_by_gender.row_totals, None)
                - assertEqual(min_count_by_gender.col_totals, None)

                - min_count_by_agegroup: grpmin(by_agegroup_gender, axis=1)  
                - assertEqual(min_count_by_agegroup.shape, (16,))
                - assertEqual(min_count_by_agegroup.dim_names, None)
                - assertEqual(min_count_by_gender.row_totals, None)
                - assertEqual(min_count_by_gender.col_totals, None)


            show_weight: show("avg weight", grpavg(weight),
                              "total population", grpsum(weight))


simulation:
    init:
        - person: [
            test_init,
            test_dump_init
        ]
#        - household: [setweight, check]
#        # pass 1: weight up to 2
#        - household: [expand]
#        - person: [expand]
#        # pass 2: weights up to 4
#        - household: [expand]
#        - person: [expand]
#        # pass 3: weights up to 8
#        - household: [expand]
#        - person: [expand]
#        # pass 4: weights up to 16
#        - household: [expand]
#        - person: [expand]
#        # pass 5: weights up to 32
#        - household: [expand]
#        - person: [expand]
#
#        - household: [check]

    processes:
        - person: [
#                   bp,
                   cleanup,

                   temp_global,
                   show_temp_global,
                   temp_global_test1,
                   show_temp_global,
                   temp_global_test2,
                   show_temp_global,

                   test_expr,
                   test_attr,
                   test_subscript,
                   test_call,

                   test_periodic_globals,
                   test_other_globals,
                   test_globals_nd,

                   test_macro,
                   test_compound,
                   agegroup,

                   test_align,
                   test_align_abs,
                   ]
        - household: [test_align_link]
        - person: [
                   check_align_link,
                   test_logit_regr,
                   test_cont_regr,
                   test_log_regr,

                   [marriage, 4],

#                   test_extra_comma,

#                   test_uninitialized_var,

                   test_new,
                   test_lag,
                   test_duration,

                   test_o2m,
                   test_mixed_links,
                   test_clone,

                   test_predictor1, test_predictor2, test_predictor3,

                   test_o2m_aggregate,
                   test_grpsum,
                   test_grpavg,
                   test_grpstd,
                   test_grpmin,
                   test_grpmedian,
                   test_grppercentile,
                   test_grpgini,

                   test_choice,

                   show_weight,
                   test_groupby,
#                   test_dump,
                   test_csv,
        ]
        - household: [num_persons, nch, maxnch,
#                      dump_csv_h
                     ]

    input:
        file: small.h5
    output:
        file: simulation.h5

    random_seed: 0
    start_period: 2002   # first simulated period
    periods: 2
    default_entity: person
