}
}
par.enf1 <- function(i) {
if ( length(identmen==identmen[i] & lienpref=="00")>0) {parent1[i] <- which(identmen==identmen[i] & lienpref=="00")}
if ( length(which(identmen==identmen[i] & lienpref=="01"))>0){  parent2[i] <- which(identmen==identmen[i] & lienpref=="01") }
}
for (i in which(enf==1)) {
par.enf1(i)
}
for (i in which(enf==2)) {
parent1[i] <-  which(identmen==identmen[i] & lienpref=="00")
}
for (i in which(enf==3)) {
parent1[i] <-  which(identmen==identmen[i] & lienpref=="01")
}
#la fonction qui met les parents et qui sera utilisé ci-après pour les petits enfants
ajout.parent <- function() {
if (length(ll)==1) {
parent1[i] <<- ll
if (length( which(identmen==identmen[i] & !enf %in% c(1,2,3) & ! lienpref %in% c("00","01") & noi != i ) ) >0 ) {
parent2[i] <<- which(identmen==identmen[i] & !enf %in% c(1,2,3) & ! lienpref %in% c("00","01") & noi != i )[1]
}
}
}
for (i in which(lienpref=="21")) {
#liste des enfants de la PR et donc des parents potentiels
ll <- which(identmen==identmen[i] & enf %in% c(1,2,3))
ajout.parent()
if (is.na(parent1[i])) {
if (mer1e[i] =="1" & per1e[i]=="1") {
ll <- intersect(ll, which(couple==1) )
ajout.parent()
}
else if (mer1e[i] =="1" & per1e[i]!="1") {
ll <- intersect(ll, which(sexe==2))
ajout.parent()
ll <- ll[1]
ajout.parent()
}
else if (mer1e[i]!="1" & per1e[i]=="1") {
ll <- intersect(ll, which(sexe==1))
ajout.parent()
ll <- ll[1]
ajout.parent()
}
}
}
# on fait aussi tourner ce qui suit parce qu'on a besoin du nombre d'enfant
for (i in which(anais<1995)) { #on ne tourne que sur les plus de 14 ans
# on définit la liste des enfants hors ménage list
list <- NULL
if (lienpref[i]=="00") {
for (k in 1:12) {
if (get(paste0("hodln",k))[i] %in% c('1','2')) {
list <- c(list,get(paste0("hodan",k))[i])
}
}
}
if (lienpref[i]=="01") {
for (k in 1:12) {
if (get(paste0("hodln",k))[i] %in% c('1','3')) {
list <- c(list,get(paste0("hodan",k))[i])
}
}
}
# on a tous les pour calculer le nombre d enfant
# on prend d'abord les enfants cohabitant
l <-  union( anais[which(parent1==i)] ,  anais[which(parent2==i)]) #nombre d'enfant cohabitant avec i
nb_enf[i] <-  length(l)+length(list)
if (length(list)>0) {
}
}
# recuperation des variables sur les enfants hors du domicile
# comme on aura besoin des infos, il faut aller les chercher
inf_pr = ind[which(ind$lienpref=="00"),c("id","res","sexe","anais","per1e","mer1e","cs42")]
inf_cj = ind[which(ind$lienpref=="01"),c("id","res","sexe","anais","per1e","mer1e","cs42")]
inf_pr$gpar = 2-( inf_pr$per1e %in% c("1","2") | inf_pr$mer1e %in% c("1","2") )
inf_cj$gpar = 2-( inf_cj$per1e %in% c("1","2") | inf_cj$mer1e %in% c("1","2") )
inf_pr = subset(inf_pr, select= c("id","res","sexe","anais","gpar","cs42"))
inf_cj = subset(inf_cj, select= c("id","res","sexe","anais","gpar","cs42"))
colnames(inf_pr) <- paste0(colnames(inf_pr),"pr")
colnames(inf_cj) <- paste0(colnames(inf_cj),"cj")
men = merge( men,inf_pr,by.x="res",by.y="respr")
men = merge( men,inf_cj,by.x="res",by.y="rescj",all=TRUE)
rm(inf_pr,inf_cj)
#TODO: gerer les valeurs manquante
#TODO: s'occuper de la precision sur les statuts
save_inf <- function(i){
liste  <<- which(men[,paste0("hodln",i)] !="")
hodln <- men[liste,paste0("hodln",i)]
sexe <- character(length(liste))
# info sur l'enfant
sexe   <- men[liste,paste0("hodsex",i)]
anais  = men[liste,paste0("hodan",i)]
couple = men[liste,paste0("hodco",i)] #couple=1 et couple=2 devront etre groupes en couple=1
couple[which(couple=="2")]<-"3"
dip6   = men[liste,paste0("hodip",i)]
nb_enf = men[liste,paste0("hodenf",i)]
# son activite
situa=  1*(men[liste,paste0("hodemp",i)]==1) +
2*(men[liste,paste0("hodcho",i)]==3) +
3*(men[liste,paste0("hodcho",i)]==3) +
4*(men[liste,paste0("hodcho",i)]==1) +
5*(men[liste,paste0("hodemp",i)]==2) +
6*(men[liste,paste0("hodcho",i)]==2) +
7*(men[liste,paste0("hodcho",i)]==4)
# on verifie que hodcho est rempli seulement quand hodemp=3
classif = ifelse( men[liste,paste0("hodpri",i)] %in% c("1","2","3","4"),
men[liste,paste0("hodpri",i)],
men[liste,paste0("hodniv",i)])
# info sur les parents
info_mere    <- matrix("",length(liste),5)
info_pere    <- matrix("",length(liste),4)
colnames(info_mere) <- c("mere","jemnais","gparmat","jemprof","jemact")
colnames(info_pere) <- c("pere","jepnais","gparpat","jepprof")
inf_pere <- function(enfants,pers) {
if (pers == "pr") {
info_pere[enfants,] <<- as.matrix(men[liste[enfants],c("idpr","anaispr","gparpr","cs42pr")])
}
if (pers == "cj") {
info_pere[enfants,] <<- as.matrix(men[liste[enfants],c("idcj","anaiscj","gparcj","cs42cj")])
}
}
inf_mere <- function(enfants,pers) {
if (pers == "pr") {
info_mere[enfants,1:4] <<- as.matrix(men[liste[enfants],c("idpr","anaispr","gparpr","cs42pr")])
}
if (pers == "cj") {
info_mere[enfants,1:4] <<- as.matrix(men[liste[enfants],c("idcj","anaiscj","gparcj","cs42cj")])
}
}
inf_pere( which(men$sexepr[liste]==1 & men[liste,paste0("hodln",i)]=="1"), "pr")
inf_mere( which(men$sexepr[liste]==1 & men[liste,paste0("hodln",i)]=="1"), "cj")
inf_pere( which(men$sexepr[liste]==2 & men[liste,paste0("hodln",i)]=="1"), "cj")
inf_mere( which(men$sexepr[liste]==2 & men[liste,paste0("hodln",i)]=="1"), "pr")
inf_pere( which(men$sexepr[liste]==1 & men[liste,paste0("hodln",i)]=="2"), "pr")
inf_mere( which(men$sexepr[liste]==2 & men[liste,paste0("hodln",i)]=="2"), "pr")
inf_pere( which(men$sexepr[liste]==1 & men[liste,paste0("hodln",i)]=="3"), "cj")
inf_mere( which(men$sexepr[liste]==2 & men[liste,paste0("hodln",i)]=="3"), "cj")
print(length(liste))
to_match = rep.int(1,length(liste))
ajout <- cbind(sexe,anais,couple,dip6,nb_enf,situa,classif,info_pere,info_mere, to_match,hodln)
}
enf_ailleurs <- save_inf(1)
for (k in 2:12) {
enf_ailleurs <- rbind(enf_ailleurs,save_inf(k))
}
#### info sur les parents
cherche_parent <- as.matrix(subset(ind, per1e == "2" | mer1e == "2",
select= c(id,sexe,anais,couple,dip14,situa,jemnais,gparmat,jemprof,jemact,
jepnais,gparpat,jepprof,per1e,mer1e,jegrave_div,classif)))
# on supprime les infos quand on ne cherche pas ce parent
pas_pere <- which(cherche_parent[,"per1e"] %in% c("1","3","4") )
cherche_parent[pas_pere,c("jepnais","gparpat","jepprof")] <- NA
pas_mere <- which(cherche_parent[,"mer1e"] %in% c("1","3","4") )
cherche_parent[pas_mere,c("jemnais","gparmat","jemprof","jemact")] <- NA
rm(pas_pere,pas_mere)
#  hodind=substr(acti,1,1)
#   if (hodind==4 & statut!=6) {hodind=5}
dip6 = character(nrow(cherche_parent))
dip6[] <- "6"
dip6[which(cherche_parent[,"dip14"]>=30)]  <- "5"
dip6[which(cherche_parent[,"dip14"]>=41)]  <- "4"
dip6[which(cherche_parent[,"dip14"]>=43)]  <- "3"
dip6[which(cherche_parent[,"dip14"]>=50)]  <- "2"
dip6[which(cherche_parent[,"dip14"]>=60)]  <- "1"
to_match = rep.int(0,nrow(cherche_parent))
cherche_parent[which(cherche_parent[,"classif"] %in% c("1","2","3")),"classif"] <- "a"
cherche_parent[which(cherche_parent[,"classif"] %in% c("4","5")),"classif"] <- "2"
cherche_parent[which(cherche_parent[,"classif"] %in% c("6","7")),"classif"] <- "1"
cherche_parent[which(cherche_parent[,"classif"] %in% c("8","9")),"classif"] <- "3"
cherche_parent[which(cherche_parent[,"classif"] %in% c("a")),"classif"] <- "4"
cherche_parent <- subset(cherche_parent,select=-c(dip14))
cherche_parent <- cbind(cherche_parent,dip6,to_match,nb_enf[which(per1e == "2" | mer1e == "2")])
colnames(cherche_parent)[which(colnames(cherche_parent)=="")] <- "nb_enf"
library(plyr)
lien = rbind.fill.matrix(cherche_parent,enf_ailleurs)
lien[16025:16100,]
lien[16025:16050,]
lien[16025:16032]
lien[16025:16032,]
f  <- paste0(dest,"lien.h5")
write.csv(lien,file=f)
user <- "IFS"
## AE
if (user=="AE_port"){
chem_patr <-"M:/data/Patrimoine/EP 2009-10/Stata/"
dest <-"M:/Myliam2/Patrimoine/lien parent enfant/"
}
if (user=="IPP"){
chem_patr <-"M:/Patrimoine/EP 2009-10/Stata/"
}
if (user=="IFS"){
chem_patr <-"T:/data/Patrimoine/EP 2009-10/Stata/"
dest <-"T:/Myliam2/Patrimoine/lien parent enfant/"
}
f  <- paste0(dest,"lien.h5")
write.csv(lien,file=f)
names(ind)
ind$pond
View(cherche_parent)
View(enf_ailleurs)
pond <- men[liste,"pond"]
f  <- paste0(dest,"lien.csv")
write.csv(lien,file=f)
install.packages("StatMatch")
library(StatMatch)
?nnd.hotdeck
?NND.hotdeck
View(lien)
names(cherche_parent)
colnames(cherche_parent)
intersect( colnames(cherche_parent) , colnames(enf_ailleurs))
match_on = intersect( colnames(cherche_parent) , colnames(enf_ailleurs))
match_on[-"to_match"]
match_on["to_match"]
match_on==["to_match"]
match_on=="to_match"
?intersect
match_on = setdiff(match_on, c("to_match"))
match_on
?NND.hotdeck
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
View(cherche_parent)
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="exact",
constrained=FALSE, constr.alg="Hungarian")
che = as.numeric(cherche_parent)
fix(che)
che = cherche_parent
class(che) <- "numeric"
che=apply(che, 1,as.numeric)
che = cherche_parent
che=apply(che, 1,as.numeric)
warnings
warnings()
View(che)
che = cherche_parent
che=apply(che, 2,as.numeric)
View(che)
range(nrow(res))
nrow(res)
res
?nrow
dim(res)
cherche_parent = cbind(res, range(nrow(cherche_parent))   )
range(nrow(cherche_parent))
seq(nrow(cherche_parent))
cherche_parent = cbind(res, seq(nrow(cherche_parent))   )
View(cherche_parent)
#### info sur les parents
cherche_parent <- as.matrix(subset(ind, per1e == "2" | mer1e == "2",
select= c(id,sexe,anais,couple,dip14,situa,jemnais,gparmat,jemprof,jemact,
jepnais,gparpat,jepprof,per1e,mer1e,jegrave_div,classif,pond)))
# on supprime les infos quand on ne cherche pas ce parent
pas_pere <- which(cherche_parent[,"per1e"] %in% c("1","3","4") )
cherche_parent[pas_pere,c("jepnais","gparpat","jepprof")] <- NA
pas_mere <- which(cherche_parent[,"mer1e"] %in% c("1","3","4") )
cherche_parent[pas_mere,c("jemnais","gparmat","jemprof","jemact")] <- NA
rm(pas_pere,pas_mere)
#  hodind=substr(acti,1,1)
#   if (hodind==4 & statut!=6) {hodind=5}
dip6 = character(nrow(cherche_parent))
dip6[] <- "6"
dip6[which(cherche_parent[,"dip14"]>=30)]  <- "5"
dip6[which(cherche_parent[,"dip14"]>=41)]  <- "4"
dip6[which(cherche_parent[,"dip14"]>=43)]  <- "3"
dip6[which(cherche_parent[,"dip14"]>=50)]  <- "2"
dip6[which(cherche_parent[,"dip14"]>=60)]  <- "1"
to_match = rep.int(0,nrow(cherche_parent))
cherche_parent[which(cherche_parent[,"classif"] %in% c("1","2","3")),"classif"] <- "a"
cherche_parent[which(cherche_parent[,"classif"] %in% c("4","5")),"classif"] <- "2"
cherche_parent[which(cherche_parent[,"classif"] %in% c("6","7")),"classif"] <- "1"
cherche_parent[which(cherche_parent[,"classif"] %in% c("8","9")),"classif"] <- "3"
cherche_parent[which(cherche_parent[,"classif"] %in% c("a")),"classif"] <- "4"
cherche_parent <- subset(cherche_parent,select=-c(dip14))
cherche_parent <- cbind(cherche_parent,dip6,to_match,nb_enf[which(per1e == "2" | mer1e == "2")])
colnames(cherche_parent)[which(colnames(cherche_parent)=="")] <- "nb_enf"
library(plyr)
lien = rbind.fill.matrix(cherche_parent,enf_ailleurs)
lien[16025:16032,]
save(c(cherche_parent,enf_ailleurs),paste0(dest,"lien.R"))
?save
save(c(cherche_parent,enf_ailleurs),file=paste0(dest,"lien.R"))
save(list(cherche_parent,enf_ailleurs),file=paste0(dest,"lien.R"))
list(cherche_parent,enf_ailleurs)
save(cherche_parent,enf_ailleurs,file=paste0(dest,"lien.R"))
match_on = intersect( colnames(cherche_parent) , colnames(enf_ailleurs))
match_on = setdiff(match_on, c("to_match"))
cherche_parent = cbind(res, seq(nrow(cherche_parent)) )
load(file=paste0(dest,"lien.R")
)
cherche_parent = cbind(cherche_parent, seq(nrow(cherche_parent)) )
View(cherche_parent)
id_match = seq(nrow(cherche_parent))
cherche_parent = cbind(cherche_parent, id_match )
View(cherche_parent)
id = cherche_parent[,c("id","id_match")]
View(id)
cherche_parent =  cherche_parent[,-c("id")]
cherche_parent =  y <- subset(cherche_parent, select= -id)
View(cherche_parent)
che=apply(che, 2,as.numeric)
che=apply(cherche_parent, 2,as.numeric)
View(che)
id_match = seq(nrow(enf_ailleurs))
enf_ailleurs = cbind(enf_ailleurs, id_match )
enf_ailleurs =  y <- subset(enf_ailleurs, select= -id)
trouve=apply(enf_ailleurs, 2,as.numeric)
View(enf_ailleurs)
View(trouve)
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="exact",
constrained=FALSE, constr.alg="Hungarian")
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="Manhattan”,
constrained=FALSE, constr.alg="Hungarian")
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="Manhattan”,
constrained=FALSE, constr.alg="Hungarian")
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
View(cherche_parent)
je=cherche_parent[which(cherche_parent["anais"]>2009-16)]
je=cherche_parent[which(cherche_parent["anais"]>2009-16),]
which(cherche_parent["anais"]>2009-16)
which(cherche_parent["anais"]>(2009-16))
cherche_parent["anais"]
which(cherche_parent[,"anais"]>(2009-16))
je=cherche_parent[which(cherche_parent[,"anais"]>(2009-16)),]
View(je)
jep=enf_ailleurs[which(enf_ailleurst[,"anais"]>(2009-16)),]
jep=enf_ailleurs[which(enf_ailleurs[,"anais"]>(2009-16)),]
View(jep)
View(cherche_parent)
View(cherche_parent)
View(je)
View(cherche_parent)
two  = cherche_parent[which(cherche_parent[,"per1e"]==2 and cherche_parent[,"mer1e"]==2),]
two  = cherche_parent[which(cherche_parent[,"per1e"]==2 & cherche_parent[,"mer1e"]==2),]
View(two)
View(enf_ailleurs)
twop = enf_ailleurs  [which(enf_ailleurs  [,"hodln"]==1,]
twop = enf_ailleurs  [which(enf_ailleurs  [,"hodln"]==1),]
View(twop)
View(cherche_parent)
mere  = cherche_parent[which(!is.na(cherche_parent[,"jemnais"]) & is.na(cherche_parent[,"jepnais"])),]
View(twop)
View(two)
View(mere)
View(enf_ailleurs)
merep = enf_ailleurs  [which(enf_ailleurs[,"mere"] !="" & enf_ailleurs[,"pere"] ==""),]
pere  = cherche_parent[which(is.na(cherche_parent[,"jemnais"]) & !is.na(cherche_parent[,"jepnais"])),]
perep = enf_ailleurs  [which(enf_ailleurs[,"mere"] =="" & enf_ailleurs[,"pere"] !=""),]
View(perep)
res <- NND.hotdeck(two, twop, match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
res <- NND.hotdeck(as.data.frame(two), as.data.frame(twop), match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
as.data.frame(two)
as.data.frame(twop)
rm(list = ls()) # Clean the workspace
gc()            # Garbage collecting (for memory efficiency)
user <- "IFS"
## AE
if (user=="AE_port"){
chem_patr <-"M:/data/Patrimoine/EP 2009-10/Stata/"
dest <-"M:/Myliam2/Patrimoine/lien parent enfant/"
}
if (user=="IPP"){
chem_patr <-"M:/Patrimoine/EP 2009-10/Stata/"
}
if (user=="IFS"){
chem_patr <-"T:/data/Patrimoine/EP 2009-10/Stata/"
dest <-"T:/Myliam2/Patrimoine/lien parent enfant/"
}
load(file=paste0(dest,"lien.R"))
library(StatMatch)
match_on = intersect( colnames(cherche_parent) , colnames(enf_ailleurs))
match_on = setdiff(match_on, c("to_match","pond"))
id_match = seq(nrow(cherche_parent))
cherche_parent = cbind(cherche_parent, id_match )
cherche_parent =  y <- subset(cherche_parent, select= -id)
cherche=apply(cherche_parent, 2,as.numeric)
id_match = seq(nrow(enf_ailleurs))
enf_ailleurs = cbind(enf_ailleurs, id_match )
enf_ailleurs =  y <- subset(enf_ailleurs, select= -id)
trouve=apply(enf_ailleurs, 2,as.numeric)
### on fait des categories
## jeunes enfants
je  = cherche_parent[which(cherche_parent[,"anais"]>(2009-16)),]
jep = enf_ailleurs  [which(enf_ailleurs  [,"anais"]>(2009-16)),]
# il faudra les traiter specifiquement
## deux parents
two  = cherche_parent[which(cherche_parent[,"per1e"]==2 & cherche_parent[,"mer1e"]==2),]
twop = enf_ailleurs  [which(enf_ailleurs  [,"hodln"]==1),]
# remarque : on devrait avoir des two non apparies dans twop puisqu'on peut avoir deux parents
# vivant sans qu'ils vivent ensemble, il faudra les basculerdans pere et mere
## mere a trouver
mere  = cherche_parent[which(!is.na(cherche_parent[,"jemnais"]) & is.na(cherche_parent[,"jepnais"])),]
merep = enf_ailleurs  [which(enf_ailleurs[,"mere"] !="" & enf_ailleurs[,"pere"] ==""),]
## pere a trouver
pere  = cherche_parent[which(is.na(cherche_parent[,"jemnais"]) & !is.na(cherche_parent[,"jepnais"])),]
perep = enf_ailleurs  [which(enf_ailleurs[,"mere"] =="" & enf_ailleurs[,"pere"] !=""),]
res <- NND.hotdeck(as.data.frame(two), as.data.frame(twop), match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
res <- NND.hotdeck(cherche_parent, enf_ailleurs, match_on,
don.class=NULL, dist.fun="Manhattan",
constrained=FALSE, constr.alg="Hungarian")
source(paste0(dest,"NND.hotdeck"))
source(paste0(dest,"NND.hotdeck.R"))
data.rec=two
data.don=twop
match.vars=match_on
if(constrained && (constr.alg=="Hungarian" || constr.alg=="hungarian")) require(clue)
constrained=FALSE
dist.fun="Manhattan"
don.class=NULL
constr.alg="Hungarian"
if(constrained && (constr.alg=="Hungarian" || constr.alg=="hungarian")) require(clue)
if(constrained && (constr.alg=="lpSolve" || constr.alg=="lpsolve")) require(lpSolve)
length(match.vars)
p <- length(match.vars)
dim(data.rec))
(!is.null(dim(data.rec)))
nr <- nrow(data.rec)
r.lab <- row.names(data.rec)
nd <- nrow(data.don)
d.lab <- row.names(data.don)
(is.null(r.lab))
r.lab <- paste("rec", r.lab, sep="=")
row.names(data.rec) <- r.lab
d.lab <- paste("don", d.lab, sep="=")
row.names(data.don) <- d.lab
row.names(data.don)
d.lab
row.names(data.don)
(!is.null(dim(data.don)))
nrow(data.don)
nd <- nrow(data.don)
row.names(data.don)
d.lab <- row.names(data.don)
data.rec=two
data.don=twop
match.vars=match_on
(!is.null(dim(data.don)))
nrow(data.don)
row.names(data.don)
dim(data.don)
(is.null(d.lab))
(is.null(r.lab))
d.lab <- paste("don", 1:nd, sep="=")
(is.null(d.lab))
row.names(data.don) <- d.lab
(!is.null(match.vars))
if(dist.fun=="Euclidean" || dist.fun=="euclidean" ||dist.fun=="Manhattan" || dist.fun=="Mahalanobis" || dist.fun=="mahalanobis" || dist.fun=="manhattan" || dist.fun=="minimax" || dist.fun=="MiniMax" || dist.fun=="Minimax"){
cat("Warning: The ", dist.fun, " distance is being used", fill=TRUE)
cat("All the categorical matching variables in rec and don \n data.frames, if present are recoded into dummies", fill=TRUE)
}
if(dist.fun=="exact" || dist.fun=="exact matching"){
cat("Warning: the exact matching distance is being used", fill=TRUE)
cat("all the matching variables in rec and don are converted \n to character variables and are treated as categorical nominal", fill=TRUE)
}
is.null(don.class)
rec=data.rec[,match.vars, drop=FALSE], don=data.don[,match.vars, drop=FALSE]
rec=data.rec[,match.vars, drop=FALSE]
don=data.don[,match.vars, drop=FALSE]
dfun=dist.fun
constr=constrained
c.alg=constr.alg
x.rec <- rec
x.don <- don
p <- ncol(rec)
p
nr <- nrow(x.rec)
nd <- nrow(x.don)
if(nr>nd) cat("Warning: the number of donors is less than \n the number of recipients", fill=TRUE)
r.lab
x.rec
rownames(x.rec)
r.lab <- rownames(x.rec)
(is.null(r.lab))
(is.null(d.lab))
require(proxy)
(is.data.frame(x.rec))
(is.data.frame(x.don))
mdist <- dist(x=x.rec, y=x.don, method=dfun, ...)
mdist <- dist(x=x.rec, y=x.don, method=dfun)
x.rec=as.data.frame(x.rec)
x.don=as.data.frame(x.don)
fact2dummy(x.rec, all=FALSE)
fact2dummy(x.don, all=FALSE)
dim(x.rec)
dxr <- dim(x.rec)
x.rec <- as.character(as.matrix(x.rec))
dim(x.rec) <- dxr
dxd <- dim(x.don)
x.don <- as.character(as.matrix(x.don))
dim(x.don) <- dxd
xx <- data.frame(rbind(x.rec, x.don))
x.rec <- xx[1:nr,]
x.don <- xx[-(1:nr),]
mdist <- gower.dist(data.x=x.rec, data.y=x.don, ...)
mdist <- gower.dist(data.x=x.rec, data.y=x.don)
mdist <- gower.dist(data.x=x.rec, data.y=x.don)
View(data.don)
